
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>statsmodels.tsa.statespace.kalman_filter &mdash; statsmodels 0.7.0 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="top" title="statsmodels 0.7.0 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
<link rel="stylesheet" href="../../_static/facebox.css" type="text/css" />
<link rel="stylesheet" href="../_static/examples.css" type="text/css" />
<script type="text/javascript" src="../../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../../_static/facebox.js">
</script>

  </head>
  <body role="document">
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../../index.html">
<img src="../../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
<li><a href ="../../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/group/pystatsmodels?hl=en">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.tsa.statespace.kalman_filter</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State Space Representation and Kalman Filter</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.representation</span> <span class="kn">import</span> <span class="n">OptionWrapper</span><span class="p">,</span> <span class="n">Representation</span><span class="p">,</span> <span class="n">FrozenRepresentation</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">prefix_kalman_filter_map</span><span class="p">,</span> <span class="n">validate_vector_shape</span><span class="p">,</span> <span class="n">validate_matrix_shape</span>
<span class="p">)</span>

<span class="c"># Define constants</span>
<span class="n">FILTER_CONVENTIONAL</span> <span class="o">=</span> <span class="mh">0x01</span>     <span class="c"># Durbin and Koopman (2012), Chapter 4</span>

<span class="n">INVERT_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">SOLVE_LU</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">INVERT_LU</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">SOLVE_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">INVERT_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x10</span>

<span class="n">STABILITY_FORCE_SYMMETRY</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="n">MEMORY_STORE_ALL</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">MEMORY_NO_FORECAST</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">MEMORY_NO_PREDICTED</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">MEMORY_NO_FILTERED</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">MEMORY_CONSERVE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MEMORY_NO_FORECAST</span> <span class="o">|</span> <span class="n">MEMORY_NO_PREDICTED</span> <span class="o">|</span> <span class="n">MEMORY_NO_FILTERED</span> <span class="o">|</span>
    <span class="n">MEMORY_NO_LIKELIHOOD</span>
<span class="p">)</span>


<div class="viewcode-block" id="KalmanFilter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter">[docs]</a><span class="k">class</span> <span class="nc">KalmanFilter</span><span class="p">(</span><span class="n">Representation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    State space representation of a time series process, with Kalman filter</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog : array_like or integer</span>
<span class="sd">        The observed time-series process :math:`y` if array like or the</span>
<span class="sd">        number of variables in the process if an integer.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int, optional</span>
<span class="sd">        The dimension of a guaranteed positive definite covariance matrix</span>
<span class="sd">        describing the shocks in the measurement equation. Must be less than</span>
<span class="sd">        or equal to `k_states`. Default is `k_states`.</span>
<span class="sd">    loglikelihood_burn : int, optional</span>
<span class="sd">        The number of initial periods during which the loglikelihood is not</span>
<span class="sd">        recorded. Default is 0.</span>
<span class="sd">    tolerance : float, optional</span>
<span class="sd">        The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">        steady-state. Default is 1e-19.</span>
<span class="sd">    results_class : class, optional</span>
<span class="sd">        Default results class to use to save filtering output. Default is</span>
<span class="sd">        `FilterResults`. If specified, class must extend from `FilterResults`.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide values for the filter,</span>
<span class="sd">        inversion, and stability methods. See `set_filter_method`,</span>
<span class="sd">        `set_inversion_method`, and `set_stability_method`.</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices. See `Representation` for more details.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are several types of options available for controlling the Kalman</span>
<span class="sd">    filter operation. All options are internally held as bitmasks, but can be</span>
<span class="sd">    manipulated by setting class attributes, which act like boolean flags. For</span>
<span class="sd">    more information, see the `set_*` class method documentation. The options</span>
<span class="sd">    are:</span>

<span class="sd">    filter_method</span>
<span class="sd">        The filtering method controls aspects of which</span>
<span class="sd">        Kalman filtering approach will be used.</span>
<span class="sd">    inversion_method</span>
<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>
<span class="sd">    stability_method</span>
<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>
<span class="sd">    conserve_memory</span>
<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">    The `filter_method` and `inversion_method` options intentionally allow</span>
<span class="sd">    the possibility that multiple methods will be indicated. In the case that</span>
<span class="sd">    multiple methods are selected, the underlying Kalman filter will attempt to</span>
<span class="sd">    select the optional method given the input data.</span>

<span class="sd">    For example, it may be that INVERT_UNIVARIATE and SOLVE_CHOLESKY are</span>
<span class="sd">    indicated (this is in fact the default case). In this case, if the</span>
<span class="sd">    endogenous vector is 1-dimensional (`k_endog` = 1), then INVERT_UNIVARIATE</span>
<span class="sd">    is used and inversion reduces to simple division, and if it has a larger</span>
<span class="sd">    dimension, the Cholesky decomposition along with linear solving (rather</span>
<span class="sd">    than explicit matrix inversion) is used. If only SOLVE_CHOLESKY had been</span>
<span class="sd">    set, then the Cholesky decomposition method would *always* be used, even in</span>
<span class="sd">    the case of 1-dimensional data.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filter_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;filter_conventional&#39;</span>
    <span class="p">]</span>

    <span class="n">filter_conventional</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_CONVENTIONAL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for conventional Kalman filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inversion_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;invert_univariate&#39;</span><span class="p">,</span> <span class="s">&#39;solve_lu&#39;</span><span class="p">,</span> <span class="s">&#39;invert_lu&#39;</span><span class="p">,</span> <span class="s">&#39;solve_cholesky&#39;</span><span class="p">,</span>
        <span class="s">&#39;invert_cholesky&#39;</span>
    <span class="p">]</span>

    <span class="n">invert_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for univariate inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU and linear solver inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_LU</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_CHOLESKY</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky and linear solver inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_CHOLESKY</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stability_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;stability_force_symmetry&#39;</span><span class="p">]</span>

    <span class="n">stability_force_symmetry</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;stability_method&#39;</span><span class="p">,</span> <span class="n">STABILITY_FORCE_SYMMETRY</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for enforcing covariance matrix symmetry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">memory_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;memory_store_all&#39;</span><span class="p">,</span> <span class="s">&#39;memory_no_forecast&#39;</span><span class="p">,</span> <span class="s">&#39;memory_no_predicted&#39;</span><span class="p">,</span>
        <span class="s">&#39;memory_no_filtered&#39;</span><span class="p">,</span> <span class="s">&#39;memory_no_likelihood&#39;</span><span class="p">,</span> <span class="s">&#39;memory_conserve&#39;</span>
    <span class="p">]</span>

    <span class="n">memory_store_all</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_STORE_ALL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for storing all intermediate results in memory (default).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_forecast</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FORECAST</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing forecasts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_predicted</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_PREDICTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing predicted state and covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_filtered</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FILTERED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing filtered state and covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_likelihood</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_conserve</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_CONSERVE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to conserve the maximum amount of memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Default filter options</span>
    <span class="n">filter_method</span> <span class="o">=</span> <span class="n">FILTER_CONVENTIONAL</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Filtering method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_CHOLESKY</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Inversion method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stability_method</span> <span class="o">=</span> <span class="n">STABILITY_FORCE_SYMMETRY</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Stability method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">MEMORY_STORE_ALL</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Memory conservation bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-19</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KalmanFilter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c"># Setup the underlying Kalman filter storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Filter options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">loglikelihood_burn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">results_class</span> <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">FilterResults</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_kalman_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_initialize_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">stability_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">filter_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">inversion_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stability_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="c"># Make sure we have endog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Must bind a dataset to the model before&#39;</span>
                               <span class="s">&#39; filtering or smoothing.&#39;</span><span class="p">)</span>

        <span class="c"># Initialize the representation matrices</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_representation</span><span class="p">()</span>

        <span class="c"># Determine if we need to (re-)create the filter</span>
        <span class="c"># (definitely need to recreate if we recreated the _statespace object)</span>
        <span class="n">create_filter</span> <span class="o">=</span> <span class="n">create_statespace</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

            <span class="n">create_filter</span> <span class="o">=</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">==</span> <span class="n">conserve_memory</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">==</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>

        <span class="c"># If the dtype-specific _kalman_filter does not exist (or if we need</span>
        <span class="c"># to re-create it), create it</span>
        <span class="k">if</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
                <span class="c"># Delete the old filter</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="c"># Setup the filter</span>
            <span class="n">cls</span> <span class="o">=</span> <span class="n">prefix_kalman_filter_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_statespaces</span><span class="p">[</span><span class="n">prefix</span><span class="p">],</span> <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="c"># Otherwise, update the filter parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
            <span class="c"># conserve_memory and loglikelihood_burn changes always lead to</span>
            <span class="c"># re-created filters</span>

        <span class="k">return</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span>

<div class="viewcode-block" id="KalmanFilter.set_filter_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : integer, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The filtering method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. Only one method is currently</span>
<span class="sd">        available:</span>

<span class="sd">        FILTER_CONVENTIONAL = 0x01</span>
<span class="sd">            Conventional Kalman filter.</span>

<span class="sd">        If the bitmask is set directly via the `filter_method` argument, then</span>
<span class="sd">        the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the filter method may also be specified by directly modifying</span>
<span class="sd">        the class attributes which are defined similarly to the keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        The default filtering method is FILTER_CONVENTIONAL.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.set_filter_method(filter_method=1)</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.set_filter_method(filter_conventional=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_conventional = True</span>
<span class="sd">        &gt;&gt;&gt; mod.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">filter_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.set_inversion_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_inversion_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_inversion_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : integer, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The inversion method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        INVERT_UNIVARIATE = 0x01</span>
<span class="sd">            If the endogenous time series is univariate, then inversion can be</span>
<span class="sd">            performed by simple division. If this flag is set and the time</span>
<span class="sd">            series is univariate, then division will always be used even if</span>
<span class="sd">            other flags are also set.</span>
<span class="sd">        SOLVE_LU = 0x02</span>
<span class="sd">            Use an LU decomposition along with a linear solver (rather than</span>
<span class="sd">            ever actually inverting the matrix).</span>
<span class="sd">        INVERT_LU = 0x04</span>
<span class="sd">            Use an LU decomposition along with typical matrix inversion.</span>
<span class="sd">        SOLVE_CHOLESKY = 0x08</span>
<span class="sd">            Use a Cholesky decomposition along with a linear solver.</span>
<span class="sd">        INVERT_CHOLESKY = 0x10</span>
<span class="sd">            Use an Cholesky decomposition along with typical matrix inversion.</span>

<span class="sd">        If the bitmask is set directly via the `inversion_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the inversion method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default inversion method is `INVERT_UNIVARIATE | SOLVE_CHOLESKY`</span>

<span class="sd">        Several things to keep in mind are:</span>

<span class="sd">        - Cholesky decomposition is about twice as fast as LU decomposition,</span>
<span class="sd">          but it requires that the matrix be positive definite. While this</span>
<span class="sd">          should generally be true, it may not be in every case.</span>
<span class="sd">        - Using a linear solver rather than true matrix inversion is generally</span>
<span class="sd">          faster and is numerically more stable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.inversion_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.solve_cholesky</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.invert_univariate</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.invert_lu</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.invert_univariate = False</span>
<span class="sd">        &gt;&gt;&gt; mod.inversion_method</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; mod.set_inversion_method(solve_cholesky=False,</span>
<span class="sd">                                     invert_cholesky=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.inversion_method</span>
<span class="sd">        16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.set_stability_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_stability_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_stability_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : integer, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The stability method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        STABILITY_FORCE_SYMMETRY = 0x01</span>
<span class="sd">            If this flag is set, symmetry of the predicted state covariance</span>
<span class="sd">            matrix is enforced at each iteration of the filter, where each</span>
<span class="sd">            element is set to the average of the corresponding elements in the</span>
<span class="sd">            upper and lower triangle.</span>

<span class="sd">        If the bitmask is set directly via the `stability_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the stability method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default stability method is `STABILITY_FORCE_SYMMETRY`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_force_symmetry</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_force_symmetry = False</span>
<span class="sd">        &gt;&gt;&gt; mod.stability_method</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.set_conserve_memory"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_conserve_memory.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_conserve_memory">[docs]</a>    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : integer, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The memory conservation method is defined by a collection of boolean</span>
<span class="sd">        flags, and is internally stored as a bitmask. The methods available</span>
<span class="sd">        are:</span>

<span class="sd">        MEMORY_STORE_ALL = 0</span>
<span class="sd">            Store all intermediate matrices. This is the default value.</span>
<span class="sd">        MEMORY_NO_FORECAST = 0x01</span>
<span class="sd">            Do not store the forecast, forecast error, or forecast error</span>
<span class="sd">            covariance matrices. If this option is used, the `predict` method</span>
<span class="sd">            from the results class is unavailable.</span>
<span class="sd">        MEMORY_NO_PREDICTED = 0x02</span>
<span class="sd">            Do not store the predicted state or predicted state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_FILTERED = 0x04</span>
<span class="sd">            Do not store the filtered state or filtered state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_LIKELIHOOD = 0x08</span>
<span class="sd">            Do not store the vector of loglikelihood values for each</span>
<span class="sd">            observation. Only the sum of the loglikelihood values is stored.</span>
<span class="sd">        MEMORY_CONSERVE</span>
<span class="sd">            Do not store any intermediate matrices.</span>

<span class="sd">        If the bitmask is set directly via the `conserve_memory` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the memory conservation method may also be specified by</span>
<span class="sd">        directly modifying the class attributes which are defined similarly to</span>
<span class="sd">        the keyword arguments.</span>

<span class="sd">        The default memory conservation method is `MEMORY_STORE_ALL`, so that</span>
<span class="sd">        all intermediate matrices are stored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.conserve_memory</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; mod.memory_no_predicted</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.memory_no_predicted = True</span>
<span class="sd">        &gt;&gt;&gt; mod.conserve_memory</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; mod.set_conserve_memory(memory_no_filtered=True,</span>
<span class="sd">                                    memory_no_forecast=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.conserve_memory</span>
<span class="sd">        7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">conserve_memory</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.filter.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">stability_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the Kalman filter to the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Determines which Kalman filter to use. Default is conventional.</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Determines which inversion technique to use. Default is by Cholesky</span>
<span class="sd">            decomposition.</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Determines which numerical stability techniques to use. Default is</span>
<span class="sd">            to enforce symmetry of the predicted state covariance matrix.</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Determines what output from the filter to store. Default is to</span>
<span class="sd">            store everything.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">            steady-state. Default is 1e-19.</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>
<span class="sd">        results : class, object, or {&#39;loglikelihood&#39;}, optional</span>
<span class="sd">            If a class which is a subclass of FilterResults, then that class is</span>
<span class="sd">            instantiated and returned with the result of filtering. Classes</span>
<span class="sd">            must subclass FilterResults.</span>
<span class="sd">            If an object, then that object is updated with the new filtering</span>
<span class="sd">            results.</span>
<span class="sd">            If the string &#39;loglikelihood&#39;, then only the loglikelihood is</span>
<span class="sd">            returned as an ndarray.</span>
<span class="sd">            If None, then the default results object is updated with the</span>
<span class="sd">            result of filtering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Set the class to be the default results class, if None provided</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span>

        <span class="c"># Initialize the filter</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">(</span>
                <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span>
                <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

        <span class="c"># Instantiate a new results object, if required</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">FilterResults</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># Initialize the state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>

        <span class="c"># Run the filter</span>
        <span class="n">kfilter</span><span class="p">()</span>

        <span class="c"># We may just want the loglikelihood</span>
        <span class="k">if</span> <span class="n">results</span> <span class="o">==</span> <span class="s">&#39;loglikelihood&#39;</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
            <span class="p">)</span>
        <span class="c"># Otherwise update the results object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Update the model features; unless we had to recreate the</span>
            <span class="c"># statespace, only update the filter options</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">only_options</span><span class="o">=</span><span class="ow">not</span> <span class="n">create_statespace</span>
            <span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>
</div>
<div class="viewcode-block" id="KalmanFilter.loglike"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglike.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood associated with the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The joint loglikelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Cannot compute loglikelihood if&#39;</span>
                               <span class="s">&#39; MEMORY_NO_LIKELIHOOD option is selected.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;loglikelihood&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="n">loglikelihood_burn</span><span class="p">:])</span>
</div>
<div class="viewcode-block" id="KalmanFilter.loglikeobs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglikeobs.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood for each observation associated with the</span>
<span class="sd">        statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `loglikelihood_burn` is positive, then the entries in the returned</span>
<span class="sd">        loglikelihood vector are set to be zero for those initial time periods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array of float</span>
<span class="sd">            Array of loglikelihood values for each observation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Cannot compute loglikelihood if&#39;</span>
                               <span class="s">&#39; MEMORY_NO_LIKELIHOOD option is selected.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;loglikelihood&#39;</span>
        <span class="n">llf_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Set any burned observations to have zero likelihood</span>
        <span class="n">llf_obs</span><span class="p">[:</span><span class="n">loglikelihood_burn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">llf_obs</span>

</div></div>
<div class="viewcode-block" id="FilterResults"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.html#statsmodels.tsa.statespace.kalman_filter.FilterResults">[docs]</a><span class="k">class</span> <span class="nc">FilterResults</span><span class="p">(</span><span class="n">FrozenRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results from applying the Kalman filter to a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Representation</span>
<span class="sd">        A Statespace representation</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int</span>
<span class="sd">        The dimension of a guaranteed positive definite</span>
<span class="sd">        covariance matrix describing the shocks in the</span>
<span class="sd">        measurement equation.</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        Datatype of representation matrices</span>
<span class="sd">    prefix : str</span>
<span class="sd">        BLAS prefix of representation matrices</span>
<span class="sd">    shapes : dictionary of name,tuple</span>
<span class="sd">        A dictionary recording the shapes of each of the</span>
<span class="sd">        representation matrices as tuples.</span>
<span class="sd">    endog : array</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : array</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : array</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : array</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : array</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : array</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : array</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : array</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    missing : array of bool</span>
<span class="sd">        An array of the same size as `endog`, filled</span>
<span class="sd">        with boolean values that are True if the</span>
<span class="sd">        corresponding entry in `endog` is NaN and False</span>
<span class="sd">        otherwise.</span>
<span class="sd">    nmissing : array of int</span>
<span class="sd">        An array of size `nobs`, where the ith entry</span>
<span class="sd">        is the number (between 0 and `k_endog`) of NaNs in</span>
<span class="sd">        the ith row of the `endog` array.</span>
<span class="sd">    time_invariant : bool</span>
<span class="sd">        Whether or not the representation matrices are time-invariant</span>
<span class="sd">    initialization : str</span>
<span class="sd">        Kalman filter initialization method.</span>
<span class="sd">    initial_state : array_like</span>
<span class="sd">        The state vector used to initialize the Kalamn filter.</span>
<span class="sd">    initial_state_cov : array_like</span>
<span class="sd">        The state covariance matrix used to initialize the Kalamn filter.</span>
<span class="sd">    filter_method : int</span>
<span class="sd">        Bitmask representing the Kalman filtering method</span>
<span class="sd">    inversion_method : int</span>
<span class="sd">        Bitmask representing the method used to</span>
<span class="sd">        invert the forecast error covariance matrix.</span>
<span class="sd">    stability_method : int</span>
<span class="sd">        Bitmask representing the methods used to promote</span>
<span class="sd">        numerical stability in the Kalman filter</span>
<span class="sd">        recursions.</span>
<span class="sd">    conserve_memory : int</span>
<span class="sd">        Bitmask representing the selected memory conservation method.</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        The tolerance at which the Kalman filter</span>
<span class="sd">        determines convergence to steady-state.</span>
<span class="sd">    loglikelihood_burn : int</span>
<span class="sd">        The number of initial periods during which</span>
<span class="sd">        the loglikelihood is not recorded.</span>
<span class="sd">    converged : bool</span>
<span class="sd">        Whether or not the Kalman filter converged.</span>
<span class="sd">    period_converged : int</span>
<span class="sd">        The time period in which the Kalman filter converged.</span>
<span class="sd">    filtered_state : array</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : array</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : array</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : array</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    forecasts : array</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : array</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : array</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>
<span class="sd">    llf_obs : array</span>
<span class="sd">        The loglikelihood values at each time period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;filter_method&#39;</span><span class="p">,</span> <span class="s">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="s">&#39;stability_method&#39;</span><span class="p">,</span>
        <span class="s">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="s">&#39;tolerance&#39;</span><span class="p">,</span> <span class="s">&#39;loglikelihood_burn&#39;</span><span class="p">,</span> <span class="s">&#39;converged&#39;</span><span class="p">,</span>
        <span class="s">&#39;period_converged&#39;</span><span class="p">,</span> <span class="s">&#39;filtered_state&#39;</span><span class="p">,</span> <span class="s">&#39;filtered_state_cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;predicted_state&#39;</span><span class="p">,</span> <span class="s">&#39;predicted_state_cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;forecasts&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts_error&#39;</span><span class="p">,</span> <span class="s">&#39;forecasts_error_cov&#39;</span><span class="p">,</span>
        <span class="s">&#39;llf_obs&#39;</span>
    <span class="p">]</span>

    <span class="n">_filter_options</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span> <span class="o">+</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span>
    <span class="p">)</span>

    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">FrozenRepresentation</span><span class="o">.</span><span class="n">_model_attributes</span> <span class="o">+</span> <span class="n">_filter_attributes</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c"># Setup caches for uninitialized objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="FilterResults.update_representation"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_representation.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.update_representation">[docs]</a>    <span class="k">def</span> <span class="nf">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">only_options</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the results to match a given model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : Representation</span>
<span class="sd">            The model object from which to take the updated values.</span>
<span class="sd">        only_options : boolean, optional</span>
<span class="sd">            If set to true, only the filter options are updated, and the state</span>
<span class="sd">            space representation is not updated. Default is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_options</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c"># Save the options as boolean variables</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_options</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="FilterResults.update_filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_filter.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.update_filter">[docs]</a>    <span class="k">def</span> <span class="nf">update_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kalman_filter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the filter results</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kalman_filter : KalmanFilter</span>
<span class="sd">            The model object from which to take the updated values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># State initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>

        <span class="c"># Save Kalman filter parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="c"># Save Kalman filter output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">converged</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_converged</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">period_converged</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>

        <span class="c"># Note: use forecasts rather than forecast, so as not to interfer</span>
        <span class="c"># with the `forecast` methods in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># If there was missing data, save the original values from the Kalman</span>
        <span class="c"># filter output, since below will set the values corresponding to</span>
        <span class="c"># the missing observations to nans.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Copy the provided arrays (which are as the Kalman filter dataset)</span>
            <span class="c"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c"># Fill in missing values in the forecast, forecast error, and</span>
        <span class="c"># forecast error covariance matrix (this is required due to how the</span>
        <span class="c"># Kalman filter implements observations that are either partly or</span>
        <span class="c"># completely missing)</span>
        <span class="c"># Construct the predictions, forecasts</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_cov_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c"># For completely missing observations, the Kalman filter will</span>
                <span class="c"># produce forecasts, but forecast errors and the forecast</span>
                <span class="c"># error covariance matrix will be zeros - make them nan to</span>
                <span class="c"># improve clarity of results.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                    <span class="c"># We can recover forecasts</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>
                <span class="c"># For partially missing observations, the Kalman filter</span>
                <span class="c"># will produce all elements (forecasts, forecast errors,</span>
                <span class="c"># forecast error covariance matrices) as usual, but their</span>
                <span class="c"># dimension will only be equal to the number of non-missing</span>
                <span class="c"># elements, and their location in memory will be in the first</span>
                <span class="c"># blocks (e.g. for the forecasts_error, the first</span>
                <span class="c"># k_endog - nmissing[t] columns will be filled in), regardless</span>
                <span class="c"># of which endogenous variables they refer to (i.e. the non-</span>
                <span class="c"># missing endogenous variables for that observation).</span>
                <span class="c"># Furthermore, the forecast error covariance matrix is only</span>
                <span class="c"># valid for those elements. What is done is to set all elements</span>
                <span class="c"># to nan for these observations so that they are flagged as</span>
                <span class="c"># missing. The variables missing_forecasts, etc. then provide</span>
                <span class="c"># the forecasts, etc. provided by the Kalman filter, from which</span>
                <span class="c"># the data can be retrieved if desired.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kalman_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman gain matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># k x n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">standardized_forecasts_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardized forecast errors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">upper</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span>

<div class="viewcode-block" id="FilterResults.predict"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.predict.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">full_results</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample and out-of-sample prediction for state space models generally</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast will be at start.</span>
<span class="sd">        end : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast will be at end.</span>
<span class="sd">        dynamic : int, optional</span>
<span class="sd">            Offset relative to `start` at which to begin dynamic prediction.</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        full_results : boolean, optional</span>
<span class="sd">            If True, returns a FilterResults instance; if False returns a</span>
<span class="sd">            tuple with forecasts, the forecast errors, and the forecast error</span>
<span class="sd">            covariance matrices. Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the prediction range is outside of the sample range, any</span>
<span class="sd">            of the state space representation matrices that are time-varying</span>
<span class="sd">            must have updated values provided for the out-of-sample range.</span>
<span class="sd">            For example, of `obs_intercept` is a time-varying component and</span>
<span class="sd">            the prediction range extends 10 periods beyond the end of the</span>
<span class="sd">            sample, a (`k_endog` x 10) matrix must be provided with the new</span>
<span class="sd">            intercept values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : FilterResults or array</span>
<span class="sd">            Either a FilterResults object (if `full_results=True`) or an</span>
<span class="sd">            array of forecasts otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All prediction is performed by applying the deterministic part of the</span>
<span class="sd">        measurement equation using the predicted state variables.</span>

<span class="sd">        Out-of-sample prediction first applies the Kalman filter to missing</span>
<span class="sd">        data for the number of periods desired to obtain the predicted states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Cannot predict if we do not have appropriate arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Predict is not possible if memory conservation&#39;</span>
                             <span class="s">&#39; has been used to avoid storing forecasts or&#39;</span>
                             <span class="s">&#39; predicted values.&#39;</span><span class="p">)</span>

        <span class="c"># Get the start and the end of the entire prediction range</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Cannot predict values previous to the sample.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>

        <span class="c"># Prediction and forecasting is performed by iterating the Kalman</span>
        <span class="c"># Kalman filter through the entire range [0, end]</span>
        <span class="c"># Then, unless `full_results=True`, forecasts are returned</span>
        <span class="c"># corresponding to the range [start, end].</span>
        <span class="c"># In order to perform the calculations, the range is separately split</span>
        <span class="c"># up into the following categories:</span>
        <span class="c"># - static:   (in-sample) the Kalman filter is run as usual</span>
        <span class="c"># - dynamic:  (in-sample) the Kalman filter is run, but on missing data</span>
        <span class="c"># - forecast: (out-of-sample) the Kalman filter is run, but on missing</span>
        <span class="c">#             data</span>

        <span class="c"># Short-circuit if end is before start</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;End of prediction must be after start.&#39;</span><span class="p">)</span>

        <span class="c"># Get the number of forecasts to make after the end of the sample</span>
        <span class="n">nforecast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="c"># Get the number of dynamic prediction periods</span>

        <span class="c"># If `dynamic=True`, then assume that we want to begin dynamic</span>
        <span class="c"># prediction at the start of the sample prediction.</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># If `dynamic=False`, then assume we want no dynamic prediction</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">ndynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Replace the relative dynamic offset with an absolute offset</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">dynamic</span>

            <span class="c"># Validate the `dynamic` parameter</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Dynamic prediction cannot begin prior to the&#39;</span>
                                 <span class="s">&#39; first observation in the sample.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s">&#39;Dynamic prediction specified to begin after the end of&#39;</span>
                     <span class="s">&#39; prediction, and so has no effect.&#39;</span><span class="p">)</span>
                <span class="n">dynamic</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s">&#39;Dynamic prediction specified to begin during&#39;</span>
                     <span class="s">&#39; out-of-sample forecasting period, and so has no&#39;</span>
                     <span class="s">&#39; effect.&#39;</span><span class="p">)</span>
                <span class="n">dynamic</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># Get the total size of the desired dynamic forecasting component</span>
            <span class="c"># Note: the first `dynamic` periods of prediction are actually</span>
            <span class="c"># *not* dynamic, because dynamic prediction begins at observation</span>
            <span class="c"># `dynamic`.</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ndynamic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="o">-</span> <span class="n">dynamic</span><span class="p">)</span>

        <span class="c"># Get the number of in-sample static predictions</span>
        <span class="n">nstatic</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">dynamic</span>

        <span class="c"># Construct the design and observation intercept and covariance</span>
        <span class="c"># matrices for start-npadded:end. If not time-varying in the original</span>
        <span class="c"># model, then they will be copied over if none are provided in</span>
        <span class="c"># `kwargs`. Otherwise additional matrices must be provided in `kwargs`.</span>
        <span class="n">representation</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;obs&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="c"># Update the matrices from kwargs for forecasts</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Model has time-invariant </span><span class="si">%s</span><span class="s"> matrix, so the </span><span class="si">%s</span><span class="s">&#39;</span>
                   <span class="s">&#39; argument to `predict` has been ignored.&#39;</span><span class="p">)</span>
        <span class="n">exception</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Forecasting for models with time-varying </span><span class="si">%s</span><span class="s"> matrix&#39;</span>
                     <span class="s">&#39; requires an updated time-varying matrix for the&#39;</span>
                     <span class="s">&#39; period to be forecasted.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nforecast</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;obs&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="n">warning</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">validate_vector_shape</span><span class="p">(</span><span class="s">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                              <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nforecast</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nforecast</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                        <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">validate_matrix_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nforecast</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">nforecast</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                        <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>

        <span class="c"># Construct the predicted state and covariance matrix for each time</span>
        <span class="c"># period depending on whether that time period corresponds to</span>
        <span class="c"># one-step-ahead prediction, dynamic prediction, or out-of-sample</span>
        <span class="c"># forecasting.</span>

        <span class="c"># If we only have simple prediction, then we can use the already saved</span>
        <span class="c"># Kalman filter output</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nforecast</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Construct the new endogenous array.</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">ndynamic</span> <span class="o">+</span> <span class="n">nforecast</span><span class="p">))</span>
            <span class="n">endog</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nstatic</span><span class="p">],</span> <span class="n">endog</span><span class="p">])</span>

            <span class="c"># Setup the new statespace representation</span>
            <span class="n">model_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;filter_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span><span class="p">,</span>
                <span class="s">&#39;inversion_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span><span class="p">,</span>
                <span class="s">&#39;stability_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span><span class="p">,</span>
                <span class="s">&#39;conserve_memory&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span><span class="p">,</span>
                <span class="s">&#39;tolerance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                <span class="s">&#39;loglikelihood_burn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="p">}</span>
            <span class="n">model_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">representation</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span>
                <span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span>
            <span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span>
            <span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">()</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="p">(</span><span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full_results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="c"># TODO: this doesn&#39;t use self, and can either be a static method or</span>
        <span class="c">#       moved outside the class altogether.</span>

        <span class="c"># Get the underlying filter</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_kalman_filter</span>

        <span class="c"># Save this (which shares memory with the memoryview on which the</span>
        <span class="c"># Kalman filter will be operating) so that we can replace actual data</span>
        <span class="c"># with predicted data during dynamic forecasting</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_representations</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">prefix</span><span class="p">][</span><span class="s">&#39;obs&#39;</span><span class="p">]</span>

        <span class="c"># print(nstatic, ndynamic, nforecast, model.nobs)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="c"># Run the Kalman filter for the first `nstatic` periods (for</span>
            <span class="c"># which dynamic computation will not be performed)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">nstatic</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
            <span class="c"># Perform dynamic prediction</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">nstatic</span> <span class="o">+</span> <span class="n">ndynamic</span><span class="p">:</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c"># Unconditional value is the intercept (often zeros)</span>
                <span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                <span class="c"># If t &gt; 0, then we can condition the forecast on the state</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># Predict endog[:, t] given `predicted_state` calculated in</span>
                    <span class="c"># previous iteration (i.e. t-1)</span>
                    <span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">model</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                        <span class="n">kfilter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span>

                <span class="c"># Advance Kalman filter</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
            <span class="c"># Perform any (one-step-ahead) forecasting</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="c"># Return the predicted state and predicted state covariance matrices</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">FilterResults</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2013, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>